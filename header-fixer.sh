#!/usr/bin/env bash

if [ $# -lt 2 -o $# -gt 3 ]; then
    cat <<EOF
Usage: $0 <clang-tidy-out> <replacement-list-file> [<marker-start-write>]

The clang-tidy-out file is a clang-tidy.out file as generated by
run-clang-tidy-cached.cc

The replacment list file has two columns, that are whitespace delimited.

If a marker is given, attempts to insert headers after this string (typically
if you have some generated file 'insert user header here' or something.

The first column contains a regular expression for a symbol that is missing,
the second column says corresponding header to include. If there are multiple
rows that include the same header, the header only has to be mentioned the
first time in that second column.
Example:

foo::SomeClass  path/to/myclass.h

Each line will be translated to a one-liner script to insert the
corresponding header, i.e. source the output to perform the necessary edits.

Tip:
To get an overview list of symbols that are used without their header, run

awk '/no header providing.*misc-include-cleaner/ {print \$6}' my_clang-tidy.out | sort | uniq -c | sort -n
EOF
    exit 0
fi

BASEDIR=$(dirname $0)
TIDY_OUT=$1
REPLACEMENT_FILE=$2
MARKER=$3

if [ ! -z "${MARKER}" ]; then
  MARKER=" -m'${MARKER}'"
fi

awk -vBASEDIR="${BASEDIR}" -vTIDY_OUT="${TIDY_OUT}" -vMARKER="${MARKER}" \
  -f- "$REPLACEMENT_FILE" <<'EOF'
{
  if ($1 == "" || match($1, /^#/)) {
    next;
  }
  CURRENT_SYMBOL=$1
  if ($2 != "") {
    # Get all the rest of the line as header. It might have comments.
    $1="";
    CURRENT_HEADER=$0;
  }
  printf("%s/insert-header.cc '%s' -q%s -e'for %s' $(awk -F: '/no header providing \"%s\".*misc-include-cleaner/ {print $1}' %s | sort | uniq)\n",
         BASEDIR, CURRENT_HEADER, MARKER, CURRENT_SYMBOL, CURRENT_SYMBOL, TIDY_OUT);
}
EOF
